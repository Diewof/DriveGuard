# Directrices de Desarrollo - DriveGuard

> **IMPORTANTE**: Este documento es leÃ­do automÃ¡ticamente por Claude Code en cada sesiÃ³n.
> Establece los estÃ¡ndares y mejores prÃ¡cticas para el desarrollo del proyecto DriveGuard.

## ğŸ¯ Objetivo del Proyecto
DriveGuard es una **BETA funcional** - un sistema de monitoreo inteligente de conducciÃ³n que integra sensores y visiÃ³n por computadora para detectar comportamientos de riesgo al volante.

**Prioridad**: Funcionalidad simple y prÃ¡ctica sobre perfecciÃ³n tÃ©cnica.

## Principios de Clean Code

### 1. DRY (Don't Repeat Yourself)
- **Eliminar duplicaciÃ³n**: Si un cÃ³digo se repite mÃ¡s de dos veces, debe extraerse a una funciÃ³n, clase o mÃ³dulo reutilizable.
- **Centralizar lÃ³gica comÃºn**: Crear utilidades y servicios compartidos para funcionalidades comunes.
- **Evitar cÃ³digo redundante**: Usar herencia, composiciÃ³n o mixins cuando sea apropiado.

**Ejemplo prÃ¡ctico:**
```dart
// âŒ Mal - CÃ³digo repetido
if (acceleration > threshold && duration > minDuration && magnitude > minMagnitude) { }
if (acceleration > threshold && duration > minDuration && magnitude > minMagnitude) { }

// âœ… Bien - ExtraÃ­do a funciÃ³n
bool meetsDetectionCriteria(double acceleration, double duration, double magnitude) {
  return acceleration > threshold && duration > minDuration && magnitude > minMagnitude;
}
```

### 2. KISS (Keep It Simple, Stupid)
- **Simplicidad sobre complejidad**: Preferir soluciones simples y directas.
- **Evitar sobre-ingenierÃ­a**: No agregar capas de abstracciÃ³n innecesarias.
- **CÃ³digo legible**: El cÃ³digo debe ser fÃ¡cil de entender a primera vista.
- **Funciones pequeÃ±as**: Cada funciÃ³n debe hacer una sola cosa y hacerla bien.

**Ejemplo prÃ¡ctico:**
```dart
// âŒ Mal - Sobre-ingenierÃ­a
class ComplexDetectorFactory {
  AbstractDetectorBuilder createBuilder(DetectorType type) {
    return DetectorBuilderFactory.getInstance()
      .getBuilder(type)
      .withStrategy(new DefaultStrategy());
  }
}

// âœ… Bien - Simple y directo
class DetectorFactory {
  Detector createDetector(DetectorType type) {
    switch (type) {
      case DetectorType.braking: return HarshBrakingDetector();
      case DetectorType.acceleration: return AggressiveAccelerationDetector();
    }
  }
}
```

### 3. YAGNI (You Ain't Gonna Need It)
- **No anticipar necesidades futuras**: Solo implementar lo que se necesita ahora.
- **Evitar caracterÃ­sticas especulativas**: No agregar funcionalidad "por si acaso".
- **Refactorizar cuando sea necesario**: Es mejor agregar funcionalidad cuando realmente se necesite.

**Ejemplo prÃ¡ctico:**
```dart
// âŒ Mal - Funcionalidad innecesaria
class SensorData {
  double x, y, z;
  DateTime timestamp;
  String deviceId;
  Map<String, dynamic> metadata; // Â¿Se usa? Probablemente no
  List<String> tags; // Â¿Se necesita? No ahora
  int version; // Â¿Para quÃ©? EspeculaciÃ³n
}

// âœ… Bien - Solo lo necesario
class SensorData {
  final double x;
  final double y;
  final double z;
  final DateTime timestamp;
}
```

## EstÃ¡ndares de CÃ³digo

### Nombrado
- **Clases**: PascalCase descriptivo (`HarshBrakingDetector`, `SensorDataProcessor`)
- **Funciones/MÃ©todos**: camelCase con verbos (`detectEvent`, `processReading`, `calculateMagnitude`)
- **Variables**: camelCase descriptivo (`accelerationMagnitude`, `detectionThreshold`)
- **Constantes**: UPPER_SNAKE_CASE (`MAX_THRESHOLD`, `DEFAULT_WINDOW_SIZE`)
- **Archivos**: snake_case (`harsh_braking_detector.dart`, `sensor_data_processor.dart`)

### Estructura de CÃ³digo
```dart
// 1. Imports (agrupados: dart, flutter, packages, relative)
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:sensors_plus/sensors_plus.dart';
import '../models/sensor_data.dart';

// 2. Constantes
const double DEFAULT_THRESHOLD = 2.5;

// 3. Clase con documentaciÃ³n
/// Detecta frenazos bruscos basÃ¡ndose en datos del acelerÃ³metro.
///
/// Utiliza un umbral configurable y filtros de ruido para reducir
/// falsos positivos.
class HarshBrakingDetector {
  // 4. Propiedades privadas
  final double _threshold;
  final NoiseFilter _filter;

  // 5. Constructor
  HarshBrakingDetector({
    double threshold = DEFAULT_THRESHOLD,
    NoiseFilter? filter,
  }) : _threshold = threshold,
       _filter = filter ?? NoiseFilter();

  // 6. MÃ©todos pÃºblicos
  DetectionEvent? detect(SensorReading reading) {
    // ImplementaciÃ³n
  }

  // 7. MÃ©todos privados
  double _calculateMagnitude(SensorReading reading) {
    // ImplementaciÃ³n
  }
}
```

## DocumentaciÃ³n

### Estructura de la carpeta `documentacion/`

La documentaciÃ³n debe organizarse por categorÃ­as temÃ¡ticas:

```
documentacion/
â”œâ”€â”€ 01-arquitectura/          # Arquitectura general del sistema
â”œâ”€â”€ 02-sensores/              # Sistema de sensores y calibraciÃ³n
â”œâ”€â”€ 03-deteccion/             # Algoritmos de detecciÃ³n
â”œâ”€â”€ 04-vision/                # Sistema de visiÃ³n por computadora
â”œâ”€â”€ 05-notificaciones/        # Sistema de alertas y notificaciones
â”œâ”€â”€ 06-ui/                    # Interfaz de usuario
â”œâ”€â”€ 07-integraciones/         # Integraciones externas (ESP32-CAM, etc.)
â”œâ”€â”€ 08-testing/               # Estrategias y planes de testing
â””â”€â”€ 09-despliegue/            # ConfiguraciÃ³n y despliegue
```

### Contenido de cada documento

Cada documento de implementaciÃ³n debe incluir:

1. **TÃ­tulo y descripciÃ³n**: QuÃ© se va a implementar
2. **Contexto**: Por quÃ© es necesario
3. **Objetivos**: QuÃ© se quiere lograr
4. **DiseÃ±o tÃ©cnico**: CÃ³mo se va a implementar
5. **Dependencias**: QuÃ© se necesita
6. **Plan de implementaciÃ³n**: Pasos especÃ­ficos
7. **Criterios de aceptaciÃ³n**: CÃ³mo saber que estÃ¡ completo
8. **Tests**: QuÃ© tests se deben crear

### Ejemplo de documento
```markdown
# ImplementaciÃ³n del Detector de Frenado Brusco

## Contexto
Los frenazos bruscos son uno de los principales indicadores de conducciÃ³n agresiva...

## Objetivos
- Detectar frenazos con desaceleraciÃ³n > 2.5 m/sÂ²
- Minimizar falsos positivos causados por baches
- Responder en < 100ms

## DiseÃ±o TÃ©cnico
### Arquitectura
[DescripciÃ³n de la arquitectura]

### Algoritmo
[PseudocÃ³digo o descripciÃ³n del algoritmo]

## ImplementaciÃ³n
### Fase 1: Estructura base
- [ ] Crear clase `HarshBrakingDetector`
- [ ] Implementar mÃ©todo `detect()`

### Fase 2: Filtros
- [ ] Agregar filtro de media mÃ³vil
- [ ] Implementar reducciÃ³n de ruido

## Tests
- `test/detectors/harsh_braking_detector_test.dart`
  - Test de detecciÃ³n bÃ¡sica
  - Test de falsos positivos
  - Test de umbrales
```

## Testing

### Principios de Testing
1. **Cobertura mÃ­nima**: 80% de cobertura de cÃ³digo
2. **Test unitario por funcionalidad**: Cada detector, filtro y procesador debe tener sus tests
3. **Casos edge**: Probar valores lÃ­mite y casos extremos
4. **Independencia**: Los tests no deben depender unos de otros
5. **Nomenclatura clara**: `test_deberÃ­aHacerAlgo_cuandoCondicion()`

### Estructura de Tests
```
test/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ detection/
â”‚   â”‚   â”œâ”€â”€ detectors/
â”‚   â”‚   â”‚   â”œâ”€â”€ harsh_braking_detector_test.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ aggressive_acceleration_detector_test.dart
â”‚   â”‚   â”‚   â””â”€â”€ sharp_turn_detector_test.dart
â”‚   â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â”‚   â”œâ”€â”€ moving_average_filter_test.dart
â”‚   â”‚   â”‚   â””â”€â”€ noise_reduction_filter_test.dart
â”‚   â”‚   â””â”€â”€ processors/
â”‚   â”‚       â””â”€â”€ sensor_data_processor_test.dart
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ device_sensor_service_test.dart
â”‚   â”‚   â””â”€â”€ notification_service_test.dart
â”‚   â””â”€â”€ vision/
â”‚       â”œâ”€â”€ detectors/
â”‚       â”‚   â”œâ”€â”€ distraction_detector_test.dart
â”‚       â”‚   â””â”€â”€ phone_detector_test.dart
â”‚       â””â”€â”€ processors/
â”‚           â””â”€â”€ frame_processor_test.dart
â””â”€â”€ integration/
    â”œâ”€â”€ sensor_detection_integration_test.dart
    â””â”€â”€ vision_detection_integration_test.dart
```

### Ejemplo de Test Unitario
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:driveguard/core/detection/detectors/harsh_braking_detector.dart';

void main() {
  group('HarshBrakingDetector', () {
    late HarshBrakingDetector detector;

    setUp(() {
      detector = HarshBrakingDetector(threshold: 2.5);
    });

    test('deberÃ­a detectar frenado cuando desaceleraciÃ³n excede umbral', () {
      // Arrange
      final reading = SensorReading(
        x: 0.0,
        y: -3.0,  // DesaceleraciÃ³n de 3 m/sÂ²
        z: 0.0,
        timestamp: DateTime.now(),
      );

      // Act
      final event = detector.detect(reading);

      // Assert
      expect(event, isNotNull);
      expect(event!.type, equals(EventType.harshBraking));
      expect(event.magnitude, greaterThan(2.5));
    });

    test('NO deberÃ­a detectar frenado cuando desaceleraciÃ³n es menor al umbral', () {
      // Arrange
      final reading = SensorReading(
        x: 0.0,
        y: -2.0,  // DesaceleraciÃ³n de 2 m/sÂ²
        z: 0.0,
        timestamp: DateTime.now(),
      );

      // Act
      final event = detector.detect(reading);

      // Assert
      expect(event, isNull);
    });

    test('deberÃ­a filtrar ruido en lecturas consecutivas', () {
      // Arrange
      final readings = [
        SensorReading(x: 0, y: -1.0, z: 0, timestamp: DateTime.now()),
        SensorReading(x: 0, y: -5.0, z: 0, timestamp: DateTime.now()), // Spike
        SensorReading(x: 0, y: -1.0, z: 0, timestamp: DateTime.now()),
      ];

      // Act
      final events = readings.map((r) => detector.detect(r)).toList();

      // Assert
      expect(events.where((e) => e != null).length, equals(0),
        reason: 'El spike aislado debe ser filtrado como ruido');
    });
  });
}
```

## Workflow de Desarrollo

### Antes de Implementar
1. **Leer documentaciÃ³n existente** en `documentacion/`
2. **Verificar que no existe cÃ³digo similar** (principio DRY)
3. **Planificar en TODO list** los pasos especÃ­ficos
4. **Crear documento de diseÃ±o** si es funcionalidad nueva

### Durante la ImplementaciÃ³n
1. **Implementar funcionalidad mÃ­nima** (YAGNI)
2. **Mantener funciones simples** (KISS)
3. **Reutilizar cÃ³digo existente** (DRY)
4. **Escribir tests unitarios** en paralelo al cÃ³digo
5. **Documentar decisiones tÃ©cnicas** en comentarios del cÃ³digo

### DespuÃ©s de Implementar
1. **Ejecutar tests**: `flutter test`
2. **Verificar cobertura**: Usar herramientas de cobertura
3. **Actualizar documentaciÃ³n** si hay cambios arquitectÃ³nicos
4. **Refactorizar** si se detecta duplicaciÃ³n o complejidad innecesaria
5. **Commit con mensaje descriptivo**

## Checklist de Pull Request

Antes de considerar una tarea como completa:

- [ ] El cÃ³digo sigue los principios DRY, KISS y YAGNI
- [ ] Existe documentaciÃ³n en `documentacion/` (si aplica)
- [ ] Existen tests unitarios con cobertura > 80%
- [ ] Los tests pasan: `flutter test`
- [ ] El cÃ³digo compila sin warnings: `flutter analyze`
- [ ] Los nombres de variables/funciones/clases son descriptivos
- [ ] No hay cÃ³digo comentado (eliminar, no comentar)
- [ ] No hay console.logs o prints de debug (usar logger apropiado)
- [ ] Las constantes mÃ¡gicas estÃ¡n definidas como constantes nombradas

## Ejemplo Completo: Agregar Nuevo Detector

### 1. PlanificaciÃ³n (TODO)
```
- [ ] Revisar documentaciÃ³n de detecciÃ³n existente
- [ ] DiseÃ±ar algoritmo del detector
- [ ] Crear archivo de detector
- [ ] Implementar lÃ³gica de detecciÃ³n
- [ ] Crear tests unitarios
- [ ] Integrar con SensorDataProcessor
- [ ] Actualizar documentaciÃ³n
- [ ] Verificar tests y anÃ¡lisis
```

### 2. DocumentaciÃ³n (`documentacion/03-deteccion/nuevo_detector.md`)
```markdown
# Detector de [Nombre]

## Objetivo
Detectar [comportamiento] basÃ¡ndose en [seÃ±ales]...

## Algoritmo
1. Recibir lectura de sensor
2. Aplicar filtro de ruido
3. Calcular magnitud
4. Comparar con umbral
5. Generar evento si excede

## ImplementaciÃ³n
Ver: `lib/core/detection/detectors/nuevo_detector.dart`

## Tests
Ver: `test/core/detection/detectors/nuevo_detector_test.dart`
```

### 3. ImplementaciÃ³n
```dart
// lib/core/detection/detectors/nuevo_detector.dart
```

### 4. Tests
```dart
// test/core/detection/detectors/nuevo_detector_test.dart
```

### 5. VerificaciÃ³n
```bash
flutter test test/core/detection/detectors/nuevo_detector_test.dart
flutter analyze
```

## FilosofÃ­a de Desarrollo para BETA

### Contexto del Proyecto
DriveGuard es una **beta funcional** que debe priorizar:
1. **Funcionalidad sobre perfecciÃ³n** - Que funcione antes que sea perfecto
2. **Simplicidad sobre sofisticaciÃ³n** - Soluciones directas antes que complejas
3. **IteraciÃ³n rÃ¡pida** - Implementar, probar, ajustar

### Prioridades para la BETA

#### âœ… LO QUE SÃ DEBE TENER
1. **DetecciÃ³n bÃ¡sica funcional**: Los detectores principales (frenado, aceleraciÃ³n, giro) deben funcionar de manera confiable
2. **Alertas efectivas**: Notificaciones visuales, sonoras y vibraciÃ³n que realmente alerten
3. **UI simple y clara**: Dashboard intuitivo, sin sobrecarga de informaciÃ³n
4. **IntegraciÃ³n ESP32-CAM bÃ¡sica**: Captura de frames y envÃ­o a la app
5. **Persistencia mÃ­nima**: Guardar historial bÃ¡sico en Firestore
6. **Tests crÃ­ticos**: Solo tests de funcionalidades core

#### âŒ LO QUE NO ES PRIORITARIO AHORA
1. **Optimizaciones prematuras**: No optimizar antes de detectar cuellos de botella reales
2. **Features avanzadas**: Machine learning complejo, anÃ¡lisis predictivo, exportaciÃ³n de datos
3. **UI/UX perfecta**: Animaciones sofisticadas, transiciones elaboradas
4. **ConfiguraciÃ³n exhaustiva**: Muchas opciones confunden, mantener lo esencial
5. **Tests de integraciÃ³n complejos**: Focus en tests unitarios de lÃ³gica crÃ­tica
6. **DocumentaciÃ³n excesiva**: Documentar lo necesario, no todo

### Reglas de Oro para BETA

#### 1. Regla del 80/20
- El 80% del valor viene del 20% de las features
- Identificar ese 20% crÃ­tico y hacerlo excelente
- El resto puede ser bÃ¡sico o incluso no existir

#### 2. Regla de las 3 Preguntas
Antes de implementar cualquier cosa, preguntarse:
1. **Â¿Es absolutamente necesario para la demo/beta?** - Si no, YAGNI
2. **Â¿Existe una forma mÃ¡s simple de hacerlo?** - Si sÃ­, KISS
3. **Â¿Ya existe cÃ³digo que haga esto?** - Si sÃ­, DRY

#### 3. Regla de "Funciona > Bonito > Perfecto"
Orden de prioridades:
1. **Funciona**: Hace lo que debe hacer (70% del esfuerzo)
2. **Bonito**: Se ve bien y es usable (20% del esfuerzo)
3. **Perfecto**: Optimizado y sin edge cases (10% del esfuerzo - BETA lo omite)

### Decisiones TÃ©cnicas para BETA

#### Manejo de Errores
```dart
// âŒ Demasiado complejo para BETA
class Result<T, E> {
  final T? value;
  final E? error;
  // ... 50 lÃ­neas mÃ¡s
}

// âœ… Suficiente para BETA
DetectionEvent? detect(SensorReading reading) {
  try {
    return _processReading(reading);
  } catch (e) {
    debugPrint('Error en detecciÃ³n: $e');
    return null;
  }
}
```

#### Estado y Persistencia
```dart
// âŒ Innecesario ahora
class CacheManager {
  final LRUCache cache;
  final DiskPersistence disk;
  final MemoryOptimizer optimizer;
}

// âœ… Directo y funcional
class SessionStorage {
  Future<void> saveSession(Session session) async {
    await FirebaseFirestore.instance
      .collection('sessions')
      .add(session.toJson());
  }
}
```

#### ConfiguraciÃ³n
```dart
// âŒ Sobre-configuraciÃ³n
class DetectorConfig {
  double threshold;
  int windowSize;
  FilterType filterType;
  double noiseThreshold;
  bool adaptiveMode;
  // ... 10 parÃ¡metros mÃ¡s
}

// âœ… ConfiguraciÃ³n esencial
class DetectorConfig {
  final double threshold;  // Lo Ãºnico que realmente necesitamos ajustar

  const DetectorConfig({this.threshold = 2.5});
}
```

### Arquitectura Simplificada para BETA

#### Estructura Recomendada
```
lib/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ detection/          # Sistema de detecciÃ³n (CORE)
â”‚   â”‚   â”œâ”€â”€ detectors/      # Detectores individuales
â”‚   â”‚   â”œâ”€â”€ models/         # Modelos de datos
â”‚   â”‚   â””â”€â”€ processors/     # Procesador principal
â”‚   â”œâ”€â”€ services/           # Servicios esenciales (CORE)
â”‚   â”‚   â”œâ”€â”€ device_sensor_service.dart
â”‚   â”‚   â”œâ”€â”€ notification_service.dart
â”‚   â”‚   â””â”€â”€ sensor_service_factory.dart
â”‚   â””â”€â”€ vision/             # Sistema de visiÃ³n (BETA SIMPLE)
â”‚       â””â”€â”€ detectors/      # Detectores de visiÃ³n bÃ¡sicos
â”œâ”€â”€ presentation/           # UI (MANTENER SIMPLE)
â”‚   â”œâ”€â”€ blocs/             # Estado con BLoC
â”‚   â”œâ”€â”€ pages/             # PÃ¡ginas principales
â”‚   â””â”€â”€ widgets/           # Widgets reutilizables
â””â”€â”€ main.dart
```

#### Capas Opcionales para BETA
- **UseCases**: Solo si la lÃ³gica de negocio es muy compleja
- **Repositories abstractos**: Solo si necesitas mÃºltiples fuentes de datos
- **Mappers**: Solo si el mapeo es complejo, sino usar `.fromJson()` directo

### Testing para BETA

#### Estrategia Minimalista
1. **Tests unitarios de detectores**: CRÃTICO
2. **Tests de servicios core**: IMPORTANTE
3. **Tests de BLoCs**: OPCIONAL (solo los mÃ¡s crÃ­ticos)
4. **Tests de widgets**: NO PRIORITARIO
5. **Tests de integraciÃ³n**: NO EN BETA

#### Ejemplo de Test MÃ­nimo Viable
```dart
void main() {
  group('HarshBrakingDetector - Tests Esenciales', () {
    test('detecta frenado fuerte', () {
      final detector = HarshBrakingDetector();
      final event = detector.detect(
        SensorReading(x: 0, y: -3.0, z: 0, timestamp: DateTime.now())
      );
      expect(event, isNotNull);
    });

    test('ignora frenado suave', () {
      final detector = HarshBrakingDetector();
      final event = detector.detect(
        SensorReading(x: 0, y: -1.0, z: 0, timestamp: DateTime.now())
      );
      expect(event, isNull);
    });
  });
}
```

### Debugging y Logging para BETA

#### Approach PragmÃ¡tico
```dart
// âœ… Simple y efectivo para BETA
class Logger {
  static void debug(String message) {
    if (kDebugMode) {
      print('[DEBUG] $message');
    }
  }

  static void error(String message, [dynamic error]) {
    debugPrint('[ERROR] $message: $error');
  }
}

// Uso
Logger.debug('Detector iniciado');
Logger.error('Fallo en lectura de sensor', e);
```

### IntegraciÃ³n ESP32-CAM para BETA

#### VersiÃ³n MÃ­nima Funcional
```dart
// Solo lo esencial: recibir frames y procesarlos
class ESP32Service {
  Future<void> startServer() async {
    final handler = Pipeline()
      .addMiddleware(logRequests())
      .addHandler(_router);

    await serve(handler, InternetAddress.anyIPv4, 8080);
  }

  Future<Response> _handleFrame(Request request) async {
    final bytes = await request.read().toBytes();
    // Procesar frame (bÃ¡sico)
    _processFrame(bytes);
    return Response.ok('OK');
  }
}
```

### DetecciÃ³n por VisiÃ³n para BETA

#### ImplementaciÃ³n Minimalista
```dart
// âŒ Demasiado ambicioso para BETA
class AIVisionProcessor {
  TensorFlowModel model;
  PreProcessor preprocessor;
  PostProcessor postprocessor;
  FeatureExtractor extractor;
  // ... modelo complejo de ML
}

// âœ… VersiÃ³n BETA: Usar ML Kit de Google (pre-entrenado)
class SimpleVisionDetector {
  final FaceDetector _faceDetector = FaceDetector();

  Future<bool> isDriverDistracted(Uint8List imageBytes) async {
    final faces = await _faceDetector.processImage(
      InputImage.fromBytes(bytes: imageBytes)
    );

    // LÃ³gica simple: si no hay cara o estÃ¡ muy rotada
    if (faces.isEmpty) return true;
    if (faces.first.headEulerAngleY?.abs() ?? 0 > 30) return true;

    return false;
  }
}
```

### MÃ©tricas de Ã‰xito para BETA

#### KPIs Funcionales
1. **Tasa de detecciÃ³n**: > 80% de eventos reales detectados
2. **Falsos positivos**: < 20% de las alertas
3. **Latencia**: < 200ms desde sensor hasta alerta
4. **Estabilidad**: App no crashea en uso normal de 30 minutos

#### KPIs NO Prioritarios (ignorar por ahora)
- OptimizaciÃ³n de baterÃ­a
- Uso de memoria
- TamaÃ±o del APK
- Tiempo de startup
- Cobertura de tests > 50%

### Checklist de Tarea BETA

Para considerar una tarea completa en BETA:

- [ ] **Funciona correctamente** en caso de uso principal
- [ ] **CÃ³digo simple** y fÃ¡cil de entender
- [ ] **No rompe** funcionalidad existente
- [ ] **Tests bÃ¡sicos** si es lÃ³gica crÃ­tica (detecciÃ³n)
- [ ] **Sin warnings** de Flutter Analyze

NO es necesario:
- [ ] ~~DocumentaciÃ³n exhaustiva~~
- [ ] ~~Tests de edge cases~~
- [ ] ~~Manejo de todos los errores posibles~~
- [ ] ~~OptimizaciÃ³n de performance~~
- [ ] ~~UI perfecta~~

### GestiÃ³n de Deuda TÃ©cnica

#### Es Aceptable en BETA
1. **CÃ³digo duplicado** si es en 2-3 lugares (no en 10)
2. **TODOs estratÃ©gicos** marcando mejoras futuras
3. **Hardcoded values** si no hay necesidad clara de configuraciÃ³n
4. **Manejo bÃ¡sico de errores** (try-catch + log)
5. **UI sin pulir** si es funcional

#### NO es Aceptable ni en BETA
1. **Crashes frecuentes**
2. **PÃ©rdida de datos del usuario**
3. **Funcionalidad core que no funciona**
4. **CÃ³digo completamente ilegible**
5. **Violaciones graves de seguridad** (tokens hardcodeados, etc.)

### Dependencias y Paquetes

#### FilosofÃ­a: Usar lo que Existe
- **ML Kit de Google** > Entrenar modelo custom
- **Audioplayers** > Implementar reproductor desde cero
- **Firebase** > Backend custom
- **Sensors Plus** > Implementar acceso a sensores

#### Evitar en BETA
- Paquetes experimentales (< 100 likes en pub.dev)
- MÃºltiples paquetes que hacen lo mismo
- Dependencias muy pesadas para features no-core

### ComunicaciÃ³n con el Usuario

#### Durante Desarrollo
```dart
// âœ… Para BETA estÃ¡ bien
showDialog(
  context: context,
  builder: (_) => AlertDialog(
    title: Text('Error'),
    content: Text('No se pudo conectar con ESP32-CAM'),
    actions: [
      TextButton(
        onPressed: () => Navigator.pop(context),
        child: Text('OK'),
      ),
    ],
  ),
);
```

No necesitamos todavÃ­a:
- Sistema de notificaciones complejo
- InternacionalizaciÃ³n (i18n)
- Accesibilidad avanzada
- Soporte para temas custom

### Plan de IteraciÃ³n

#### Sprint 1: Funcionalidad Core (AHORA)
- DetecciÃ³n de sensores funcionando
- Alertas bÃ¡sicas operativas
- Dashboard mostrando datos en tiempo real
- Historial bÃ¡sico

#### Sprint 2: VisiÃ³n BÃ¡sica (SIGUIENTE)
- ESP32-CAM enviando frames
- DetecciÃ³n simple de rostro/distracciÃ³n
- IntegraciÃ³n con sistema de alertas

#### Sprint 3: Refinamiento (DESPUÃ‰S)
- Mejorar precisiÃ³n de detectores
- Ajustar umbrales basado en testing real
- Pulir UI segÃºn feedback

#### Post-BETA (FUTURO)
- Optimizaciones de performance
- Tests comprehensivos
- Features avanzadas
- Refactoring de deuda tÃ©cnica

## Recursos Adicionales

- **Flutter Testing**: https://docs.flutter.dev/testing
- **Clean Code**: Robert C. Martin
- **Effective Dart**: https://dart.dev/guides/language/effective-dart
- **ML Kit**: https://developers.google.com/ml-kit
- **Firebase**: https://firebase.google.com/docs/flutter/setup

## Comandos Ãštiles

```bash
# Verificar que todo compila sin warnings
flutter analyze

# Correr tests (solo los que tengas)
flutter test

# Limpiar build (si algo no funciona)
flutter clean && flutter pub get

# Ver logs en tiempo real
flutter logs

# Instalar en dispositivo fÃ­sico
flutter run --release
```

## Preguntas Frecuentes - Desarrollo BETA

**Q: Â¿Debo crear tests para todo?**
A: No. Solo tests para detectores y lÃ³gica crÃ­tica. UI tests pueden esperar.

**Q: Â¿CuÃ¡ndo refactorizar cÃ³digo duplicado?**
A: Si se repite > 3 veces Y es probable que cambie junto. Sino, dÃ©jalo.

**Q: Â¿Debo usar UseCases/Repository pattern?**
A: Si la lÃ³gica es simple, no. BLoC puede llamar al servicio directo.

**Q: Â¿Manejar todos los edge cases?**
A: No en BETA. Maneja el 80% de casos comunes bien.

**Q: Â¿Optimizar rendimiento ahora?**
A: Solo si hay un problema evidente. No optimizar "por si acaso".

**Q: Â¿Documentar cada funciÃ³n?**
A: Solo las no obvias o con lÃ³gica compleja. El cÃ³digo debe ser auto-documentado.

---

**Ãšltima actualizaciÃ³n**: 2025-10-28
**Mantenido por**: Claude AI Assistant
**VersiÃ³n**: BETA Focus Edition
